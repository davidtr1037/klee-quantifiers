# State Merging with Quantifiers
This is an extension of KLEE which enables to perform state mering using quantified constraints.

## Usage
Consider the following example:
```
#include <stdlib.h>
#include <string.h>
#include <klee/klee.h>

int main(int argc, char *argv[]) {
  size_t length;
  klee_make_symbolic(&length, sizeof(length), "length");
  klee_assume(length >= 1);
  klee_assume(length <= 4);

  char *str = malloc(length);
  klee_make_symbolic(str, length, "str");
  str[length - 1] = 0;

  char *p = strchr(str, 'a');
  if (p) {
    klee_print_expr("p", p);
  }

  return 0;
}
```

To compile it, run the following command:
```
clang -g -c -emit-llvm -I <klee_src>/include <source_file> -o <bitcode_file>
```

To apply our state merging approach in the `strchr` loop, run the following command:
```
klee \
    -libc=uclibc \
    -solver-backend=z3 \
    -z3-smt-relevancy=1 \
    -search=dfs \
    -write-kqueries \
    -use-merge=1 \
    -use-loop-merge=1 \
    -use-optimized-merge=1 \
    -optimize-using-exec-tree=1 \
    -extend-exec-tree-on-switch=1 \
    -extend-exec-tree-on-symbolic-branch=1 \
    -allocate-sym-size=1 \
    -capacity=10 \
    -use-merge-transformation=1 \
    -use-join-transformation=1 \
    -use-incremental-merging-search=1 \
    -split-by-pattern=1 \
    -optimize-using-quantifiers=1 \
    -simplify-merged-constraint-on-single-pattern=0 \
    -use-small-model-solver=1 \
    -add-bound-constraints=1 \
    -generate-ematching-constraints=1 \
    -duplicate-model=1 \
    -repair-model=1 \
    <bitcode_file>
```

Here, the state merging operation results in two merged symbolic states.
The resulting quantified path constraints are located in the output directory generated by KLEE:
```
<klee_out>/test000006.kquery
<klee_out>/test000007.kquery
```
